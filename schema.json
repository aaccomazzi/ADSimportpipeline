//          TOP LEVEL SCHEMA
[
  {
    '@bibcode':         '',
    'JSON_fingerprint': '',
    'metadata': {
      'general':    {},
      'properties': {},
      'references': {},
      'relations':  {},
    },
    'text' {
      'body': '',
      'acknowledgments': '',
      'creation': '',
      'last_mod': '',
    },
    'last_mod': '',

  },
]


//          METADATA-BLOCK SCHEMA
// GENERAL
general = {
  'arxivcategories': ['',]

  'keywords': [
    {
    '@origin': '',
    '@type': '',
    'channel': '',
    'original': '',
    'normalized': '',
    },
  ]

  'title': [
    {
      '@lang': '',
      '#text': '',
    },
  ],

  'abstract: [
    {
      '@origin' : '',
      '@lang': '',
      '#text': '',
    },
  ],

//-affiliations are currently combined to a single long string. Is splitting on ";" correct to uncombine?
// ...Or, should we keep the current implementation of 1 author-> 1 affiliation, where affiliation is a long string?
  'author': [
    {
      '@nr': '',
      'type': '',
      'affiliations': ['',],
      'emails': ['',]
      'orcid': '',
      'name': {
        'native': '',
        'western': '',
        'normalized': '',
      },
    },
  ],

  'pagination': {
    '@origin': '',
    'page': '',
    'page_last': '',
    'page_range': '',       // somewhat redundant, but there are weird cases (e.g. STI) where it's not just "firstpage-lastpage"
    'page_count': '',       // number of pages (int)
    'electronic_id': '',    // usually populated when page is null, but not always 
  },

  'publication': {
    '@origin': '',
    'volume': '',
    'issue': '',
    'name': {
      'raw': '',
      'canonical': '',
  },
 },

  'dates': {
    'identifier-string-N': {   // ???
      '@origin': '',
      'content': '',
    },
  },

  // We need a structure to maintain alternate publication venues
  // This is where we'd put publication info that we have handled with
  // alternate bibcodes (but not _all_ alternate bibcodes, which makes 
  // it difficult to deal with).  We need this medatadata for two reasons:
  // 1. so we can create complete output when required (e.g. bibtex)
  // 2. so we can resolve references made to the alternate venue (more important)
  // To be reviewed by CSG, etc.
  'altpublication': [
    '@origin': '',
    'publication': {
      '@origin': '',
      'volume': '',
      'issue': '',
      'name': '',
      'canonical': '',
    },
    'pagination': {
      'page': '',
      'page_last': '',
      'page_range': '',
      'page_count': '',
      'electronic_id': '',
    }
    'dates': {
      'identifier-string-N': {   // ???
        '@origin': '',
        'content': '',
      },
    },
  ],

  'conf_metadata': {           // this should be covered by the proper associates
    '@origin': '',
    'content': '',
  },

  'pubnote' : '',

  'isbns': [
    {
      '@origin': '',
      'content': '',
    },
  ],

  'issns': [
    {
      '@origin': '',
      'content': '',
    },
  ],

  'doi': [              // we'll have documents with multiple dois for sure
    {
      '@origin': '',
      'content': '',
    },
  ],

// This should also be ignored I think in favor of 'supplemental' 
  //  'instruments': [
  //  { 
  //    '@origin': '',
  //    'content': '',
  //  },
  //],

  'copyright': {
    '@origin': '',
    'content': '',
  },
  
  'comment': {
    '@origin': '',
    'content': '',
  },


//Plan to ignore ADSExports; instead this info will be stored in the 'supplemental' collection
  // 'objects': [
  //   {
  //     '@origin': '',
  //     'content': '',
  //   },
  // ],
}

// PROPERTIES 
properties = {
  'databases': [
    {
      '@origin': '',
      'content': '',
    },
  ],

  'pubtype': {
    '@origin': '',
    'content': '',
  },

  'bibgroups': [
    {
      '@origin':'',
      'content': '',
    },
  ],

  'associates': [
    {
      '@origin':'',
      'content': '',
      'comment': '',
    },
  ],

// Should these all be booleans?
  'openaccess': true||false,

  'nonarticle': true||false,

  'ocrabstract': true||false,

  'private': true||false,

  'refereed': true||false,
}

// REFERENCES
references = [
  {
    '@origin':    '',
    'bibcode':    '',
    'doi':        '',
    'score':      '',
    'extension':  '',
    'content':    '',
  },
],

// RELATIONS
relations = {
  'preprint': [
    {
      '@origin':'',
      '@ecode': '',
      'content': '',
    },
  ]

  'alternates': [
    {
      '@origin':'',
      '@type': '',
      'content': '',,
    },
  ],

  'links': [
    {
      '@origin': '',
      'type': '',
      'url': '',
      'title': '',
      'count': '',
    },
  ],
}
